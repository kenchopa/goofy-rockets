<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Goofy Rockets</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin-top: 50px;
    }

    .multiplier {
      font-size: 48px;
      color: green;
    }

    .crashed {
      color: red;
    }

    #betInput {
      padding: 10px;
      font-size: 16px;
      margin: 10px;
    }

    #placeBetBtn,
    #cashOutBtn {
      padding: 10px 20px;
      font-size: 18px;
      cursor: pointer;
      margin: 10px;
    }

    #placeBetBtn {
      background-color: #4CAF50;
      color: white;
    }

    #cashOutBtn {
      background-color: #f44336;
      color: white;
    }

    #message {
      margin-top: 20px;
      font-size: 16px;
    }

    /* Game Area Styles */
    #gameArea {
      width: 100%;
      height: 400px;
      /* Adjust the height as needed */
      margin-top: 50px;
      background-color: #000;
      /* Fallback background color */
    }
  </style>
</head>

<body>

  <h1>Goofy Rockets</h1>
  <div id="multiplier" class="multiplier">1.00x</div>

  <div>
    <input type="number" id="betInput" placeholder="Enter bet amount" min="1" />
    <button id="placeBetBtn">Place Bet</button>
    <button id="cashOutBtn" disabled>Cash Out</button>
  </div>

  <div id="message"></div>

  <!-- Three.js Canvas Container -->
  <div id="gameArea"></div>

  <!-- Socket.IO and Three.js Libraries -->
  <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    const socket = io('http://localhost:3002');
    const multiplierDiv = document.getElementById('multiplier');
    const placeBetBtn = document.getElementById('placeBetBtn');
    const cashOutBtn = document.getElementById('cashOutBtn');
    const betInput = document.getElementById('betInput');
    const messageDiv = document.getElementById('message');

    // Three.js variables
    let scene, camera, renderer;
    let rocketMesh;
    let explosionMesh;
    let isExploding = false;
    let explosionScale = 0.1;

    let hasPlacedBet = false;

    // Initialize the Three.js scene
    function initThreeJS() {
      // Create a scene
      scene = new THREE.Scene();

      // Create a camera (PerspectiveCamera)
      camera = new THREE.PerspectiveCamera(
        75, // Field of view
        window.innerWidth / 400, // Aspect ratio (adjusted for the #gameArea height)
        0.1, // Near clipping plane
        1000 // Far clipping plane
      );
      camera.position.z = 5;

      // Create a renderer and add it to the #gameArea
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, 400); // Width x Height
      document.getElementById('gameArea').appendChild(renderer.domElement);

      // Add lighting
      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(0, 1, 1).normalize();
      scene.add(light);

      // Create the rocket
      createRocket();

      // Start the animation loop
      animate();
    }

    // Function to create a simple rocket model
    function createRocket() {
      const rocketGroup = new THREE.Group();

      // Rocket body (Cylinder)
      const bodyGeometry = new THREE.CylinderGeometry(0.2, 0.2, 2, 32);
      const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      rocketGroup.add(body);

      // Rocket nose (Cone)
      const noseGeometry = new THREE.ConeGeometry(0.2, 0.5, 32);
      const noseMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
      const nose = new THREE.Mesh(noseGeometry, noseMaterial);
      nose.position.y = 1.25;
      rocketGroup.add(nose);

      // Rocket fins (using BoxGeometry)
      const finGeometry = new THREE.BoxGeometry(0.1, 0.5, 0.05);
      const finMaterial = new THREE.MeshLambertMaterial({ color: 0x0000ff });

      const fin1 = new THREE.Mesh(finGeometry, finMaterial);
      fin1.position.set(0.25, -1, 0);
      rocketGroup.add(fin1);

      const fin2 = fin1.clone();
      fin2.position.set(-0.25, -1, 0);
      rocketGroup.add(fin2);

      // Set the initial position
      rocketGroup.position.x = -5; // Start from the left side

      // Rotate the rocket to be horizontal
      rocketGroup.rotation.z = Math.PI / 2;

      // Add to the scene
      scene.add(rocketGroup);

      rocketMesh = rocketGroup;
    }

    // Function to create an explosion effect
    function createExplosion(x, y) {
      // Create a sphere
      const geometry = new THREE.SphereGeometry(0.1, 32, 32);
      const material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
      explosionMesh = new THREE.Mesh(geometry, material);
      explosionMesh.position.set(x, y, 0);
      scene.add(explosionMesh);

      // Start explosion animation
      isExploding = true;
      explosionScale = 0.1;
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      // Optional: Add rotation for a more dynamic effect
      if (rocketMesh) {
        //rocketMesh.rotation.y += 0.01; // Commented out to prevent unwanted rotation
      }

      // Handle explosion animation
      if (isExploding && explosionMesh) {
        explosionScale += 0.2;
        explosionMesh.scale.set(explosionScale, explosionScale, explosionScale);

        // Fade out
        explosionMesh.material.opacity = 1 - (explosionScale / 5);
        explosionMesh.material.transparent = true;

        if (explosionScale > 5) {
          // End explosion
          isExploding = false;
          scene.remove(explosionMesh);
        }
      }

      // Render the scene
      renderer.render(scene, camera);
    }

    // Function to update the rocket's position
    function updateRocketPosition(multiplier) {
      if (!rocketMesh) return;

      // Parameters for the curve
      const maxDistance = 10; // Total horizontal distance
      const maxMultiplier = 10;
      const amplitude = 2; // Amplitude of the sine wave
      const frequency = 1; // Frequency of the sine wave

      // Calculate normalized time based on the multiplier
      const t = (Math.log(multiplier) / Math.log(maxMultiplier));
      const positionX = t * maxDistance - 5; // Range from -5 to +5
      const positionY = amplitude * Math.sin(frequency * positionX);

      rocketMesh.position.x = positionX;
      rocketMesh.position.y = positionY;

      // Calculate the angle of the tangent to the curve for rotation
      const delta = 0.01; // Small change in x to compute derivative
      const x1 = positionX;
      const y1 = amplitude * Math.sin(frequency * x1);
      const x2 = x1 + delta;
      const y2 = amplitude * Math.sin(frequency * x2);

      const angle = Math.atan2(y2 - y1, x2 - x1);

      // Rotate the rocket to align with the tangent
      rocketMesh.rotation.z = angle;

      // Optional: Keep the rocket upright in the z-axis
      // rocketMesh.rotation.x = 0;
      // rocketMesh.rotation.y = 0;
    }

    // Handle window resize
    window.addEventListener('resize', onWindowResize);

    function onWindowResize() {
      camera.aspect = window.innerWidth / 400;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, 400);
    }

    // Update the multiplier and rocket position in real-time
    socket.on('multiplierUpdate', (data) => {
      multiplierDiv.textContent = data.multiplier.toFixed(2) + 'x';
      multiplierDiv.classList.remove('crashed');

      // Update rocket position
      updateRocketPosition(data.multiplier);
    });

    // Handle when the game crashes
    socket.on('gameCrash', (data) => {
      multiplierDiv.textContent = data.crashPoint + 'x (Crashed!)';
      multiplierDiv.classList.add('crashed');
      cashOutBtn.disabled = true;
      messageDiv.textContent = 'Game crashed! Waiting for the next round...';

      // Create an explosion at the last position
      if (rocketMesh) {
        createExplosion(rocketMesh.position.x, rocketMesh.position.y);
        // Remove the rocket from the scene
        scene.remove(rocketMesh);
        rocketMesh = null;
      }

      // Reset rocket position after a delay
      setTimeout(() => {
        betInput.disabled = false;
        placeBetBtn.disabled = false;
        cashOutBtn.disabled = true;
        messageDiv.textContent = '';
        hasPlacedBet = false; // Reset the bet state

        // Remove explosion if still present
        if (explosionMesh) {
          scene.remove(explosionMesh);
          explosionMesh = null;
        }

        // Recreate the rocket
        createRocket();
      }, 5000); // Adjust the delay as needed
    });

    // Handle successful bet placement
    socket.on('betSuccess', (data) => {
      messageDiv.textContent = `Bet placed: ${data.amount}`;
      placeBetBtn.disabled = true;
      betInput.disabled = true;
      cashOutBtn.disabled = false;
      hasPlacedBet = true;
    });

    // Handle failed bet placement
    socket.on('betFailed', (data) => {
      messageDiv.textContent = `Bet failed: ${data.message}`;
    });

    // Handle cash-out success
    socket.on('cashOutSuccess', (data) => {
      messageDiv.textContent = `Cashed out! Payout: ${data.payout}`;
      cashOutBtn.disabled = true;
    });

    // Handle cash-out failure
    socket.on('cashOutFailed', (data) => {
      messageDiv.textContent = `Cash-out failed: ${data.message}`;
    });

    // Handle losing the bet
    socket.on('playerLost', (data) => {
      messageDiv.textContent = data.message;
      placeBetBtn.disabled = false;
      betInput.disabled = false;
      cashOutBtn.disabled = true;
      hasPlacedBet = false;
    });

    // Place a bet when the button is clicked
    placeBetBtn.addEventListener('click', () => {
      const betAmount = parseFloat(betInput.value);
      if (!isNaN(betAmount) && betAmount > 0) {
        socket.emit('placeBet', betAmount);
      } else {
        messageDiv.textContent = 'Please enter a valid bet amount.';
      }
    });

    // Cash out when the button is clicked
    cashOutBtn.addEventListener('click', () => {
      if (hasPlacedBet) {
        socket.emit('cashOut');
      }
    });

    // Initialize Three.js when the window loads
    window.addEventListener('load', initThreeJS);
  </script>
</body>

</html>
